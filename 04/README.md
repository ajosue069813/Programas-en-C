# Lectura y decodificación de un paquete de (TCP|UDP)/IP 

Primeramente se declararon algunas estructuras en dónde se colocan los datos que se piden para el caso de IP se requiere que se muestre la versión, tamaño de cabecera, longitud total, protocolo, suma de control de cabecera, dirección IP de origen y la dirección IP destino, por lo que se declararon estructuras para dichos requerimientos, en este caso las estructuras van a almacenar los datos solicitados, además de que para ello se usan punteros.
La siguiente estructura que se declara corresponde a los datos del datagrama de TCP en caso de que el archivo que se lea contengan un protocolo TCP, en dónde los datos que componen la estructura son el puerto de origen, puerto destino, número de secuencia, número de ACK, longitud de cabecera, control, checksum y los datos.
Por ultimo la estructura siguiente corresponde a los datos de UDP en caso de que sea un protocolo UDP los datos que se quieren obtener de ese archivo son el puerto de origen, puerto destino, longitud del mensaje, suma de verificación y datos, cada dato se declara con un tipo de dato diferente sin signo, esto para evitar que se lean elementos negativos que no nos interesan, la declaracion del tipo de varibale va a depender del tamaño establecido en cada uno de los datagramas tanto de IP, UDP y TCP.

Después de ello se realiza la declaración de funciones en el main, además de que en el main se van a recibir los argumentos argc y argv para poder hacer la lectura del archivo de forma binaria, enseguida se declara el código correspondiente para poder leer el archivo, la lectura de este archivo se hace de forma binaria ya que si se quiere leer de manera “normal” existen algunos caracteres que no se van a leer correctamente, después de eso se declaran las funciones correspondientes para poder hacer la lectura y poder decodificar, cabe destacar que en los archivos a leer los primeros 14 bytes son lo de la capa de red (Ethernet) mientras que el resto de los bytes son los valores a decodificar, tomando en cuenta cada dato que se pide tiene una posición diferente en el encabezado, para leer cada unos de los datos se debe de tomar en cuenta que cada uno de los bytes va a estar en una determinada dirección de memoria y que al menos la mayoría de los datos son estáticos eso quiere decir que van a tener una posición de memoria establecida lo que facilita un poco la decodificación del archivo, y dependiendo de si es un protocolo TCP/IP o UDP/IP esto va a imprimir ciertos datos en la consola, bueno una vez esto las demas funciones corresponden a ir acomodando respectivamente cada uno de los datos con las direcciones correspondientes al vector en dónde se encuentra la información del archivo dependiendo de esas direcciones los datos son asignados a cada una de las variables definidas en cada una de las estructuras que se definieron al inicio, después de eso se tienen funciones las funciones para imprimir cada uno de los elementos que se pide, esto de hace con punteros para obtener cada uno de los datos correspondientes e imprimir si es un protocolo TCP/IP imprime todos los datos de la estructura IP además de todos los datos de la estructura TCP, de ser lo contrario que se trate de un protocolo UDP/IP lo que se hace es que se van a imprimir cada uno de los datos que conforman la estructura de IP y después todos los datos correspondientes a UDP, esta acción se realiza en el main con una condicional que va a diferenciar entre si se trata de un protocolo UDP y un TCP, cada protocolo tiene un número específico lo que sirve para poder identificar que protocolo se está utilizando.
De igual manera cuando se imprimen los datos se observa que hay una función para hacer un corrimiento de bits esto pasa porque hay un acomodamiento big endian y lo que se quiere es que sea little endian pero esto solo pasa con algunos tipos de variables no con todas por la forma en que se acomodan en sus datagramas correspondientes. 

Para obtener "data" en TCP se hace un offset de 32 porque viendo el segmento de cabecera se tiene primero un corrimiento de 20 bytes y después uno de  32 bytes, esto va a depender del tamaño del offset que en este caso el offset es de 8 entonces 8x4 es igual a 32bytes, de ahí se comienza a obtener "data", para los demás casos la lógica es similar.
Una cosa importante que ver es que todos los datos que se muestran en la consola como resultado se encuentran en hexadecimal, "data" se puede imprimir en forma de una cadena de caracteres por lo que "data" debe de mostrar un "Hello world!"
